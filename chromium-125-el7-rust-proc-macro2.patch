diff -Nur chromium-123.0.6312.122/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.78/build.rs chromium-125.0.6422.60/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.80/build.rs
--- chromium-123.0.6312.122/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.78/build.rs	2024-04-10 23:25:21.000000000 +0200
+++ chromium-125.0.6422.60/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.80/build.rs	2024-05-15 23:47:24.000000000 +0200
@@ -36,10 +36,10 @@
 
 use std::env;
 use std::ffi::OsString;
+use std::iter;
 use std::path::Path;
 use std::process::{self, Command, Stdio};
 use std::str;
-use std::u32;
 
 fn main() {
     let rustc = rustc_minor_version().unwrap_or(u32::MAX);
@@ -63,6 +63,11 @@
         println!("cargo:rustc-cfg=no_source_text");
     }
 
+    if rustc < 79 {
+        println!("cargo:rustc-cfg=no_literal_byte_character");
+        println!("cargo:rustc-cfg=no_literal_c_string");
+    }
+
     if !cfg!(feature = "proc-macro") {
         println!("cargo:rerun-if-changed=build.rs");
         return;
@@ -138,15 +143,15 @@
     let out_dir = cargo_env_var("OUT_DIR");
     let probefile = Path::new("build").join("probe.rs");
 
-    // Make sure to pick up Cargo rustc configuration.
-    let mut cmd = if let Some(wrapper) = env::var_os("RUSTC_WRAPPER") {
-        let mut cmd = Command::new(wrapper);
-        // The wrapper's first argument is supposed to be the path to rustc.
-        cmd.arg(rustc);
-        cmd
-    } else {
-        Command::new(rustc)
-    };
+    let rustc_wrapper = env::var_os("RUSTC_WRAPPER").filter(|wrapper| !wrapper.is_empty());
+    let rustc_workspace_wrapper =
+        env::var_os("RUSTC_WORKSPACE_WRAPPER").filter(|wrapper| !wrapper.is_empty());
+    let mut rustc = rustc_wrapper
+        .into_iter()
+        .chain(rustc_workspace_wrapper)
+        .chain(iter::once(rustc));
+    let mut cmd = Command::new(rustc.next().unwrap());
+    cmd.args(rustc);
 
     if !rustc_bootstrap {
         cmd.env_remove("RUSTC_BOOTSTRAP");
@@ -156,6 +161,7 @@
         .arg("--edition=2021")
         .arg("--crate-name=proc_macro2")
         .arg("--crate-type=lib")
+        .arg("--cap-lints=allow")
         .arg("--emit=dep-info,metadata")
         .arg("--out-dir")
         .arg(out_dir)
diff -Nur chromium-123.0.6312.122/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.78/Cargo.toml chromium-125.0.6422.60/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.80/Cargo.toml
--- chromium-123.0.6312.122/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.78/Cargo.toml	2024-04-10 23:25:21.000000000 +0200
+++ chromium-125.0.6422.60/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.80/Cargo.toml	2024-05-15 23:47:24.000000000 +0200
@@ -13,7 +13,7 @@
 edition = "2021"
 rust-version = "1.56"
 name = "proc-macro2"
-version = "1.0.78"
+version = "1.0.80"
 authors = [
     "David Tolnay <dtolnay@gmail.com>",
     "Alex Crichton <alex@alexcrichton.com>",
diff -Nur chromium-123.0.6312.122/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.78/Cargo.toml.orig chromium-125.0.6422.60/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.80/Cargo.toml.orig
--- chromium-123.0.6312.122/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.78/Cargo.toml.orig	2024-04-10 23:25:21.000000000 +0200
+++ chromium-125.0.6422.60/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.80/Cargo.toml.orig	2024-05-15 23:47:24.000000000 +0200
@@ -1,6 +1,6 @@
 [package]
 name = "proc-macro2"
-version = "1.0.78"
+version = "1.0.80"
 authors = ["David Tolnay <dtolnay@gmail.com>", "Alex Crichton <alex@alexcrichton.com>"]
 autobenches = false
 categories = ["development-tools::procedural-macro-helpers"]
diff -Nur chromium-123.0.6312.122/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.78/.cargo_vcs_info.json chromium-125.0.6422.60/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.80/.cargo_vcs_info.json
--- chromium-123.0.6312.122/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.78/.cargo_vcs_info.json	2024-04-10 23:25:21.000000000 +0200
+++ chromium-125.0.6422.60/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.80/.cargo_vcs_info.json	2024-05-15 23:47:24.000000000 +0200
@@ -1,6 +1,6 @@
 {
   "git": {
-    "sha1": "d850a1db5e3fe7732d62cacbfc4145e496c2a80e"
+    "sha1": "da51f8d005cc5d8299c1872fad9bbe63b07c31c7"
   },
   "path_in_vcs": ""
 }
\ Kein Zeilenumbruch am Dateiende.
diff -Nur chromium-123.0.6312.122/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.78/.github/workflows/ci.yml chromium-125.0.6422.60/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.80/.github/workflows/ci.yml
--- chromium-123.0.6312.122/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.78/.github/workflows/ci.yml	2024-04-10 23:25:21.000000000 +0200
+++ chromium-125.0.6422.60/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.80/.github/workflows/ci.yml	2024-05-15 23:47:24.000000000 +0200
@@ -198,6 +198,7 @@
     timeout-minutes: 45
     steps:
       - uses: actions/checkout@v4
+      - uses: dtolnay/rust-toolchain@stable
       - uses: dtolnay/install@cargo-outdated
       - run: cargo outdated --workspace --exit-code 1
       - run: cargo outdated --manifest-path fuzz/Cargo.toml --exit-code 1
diff -Nur chromium-123.0.6312.122/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.78/src/fallback.rs chromium-125.0.6422.60/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.80/src/fallback.rs
--- chromium-123.0.6312.122/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.78/src/fallback.rs	2024-04-10 23:25:21.000000000 +0200
+++ chromium-125.0.6422.60/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.80/src/fallback.rs	2024-05-15 23:47:24.000000000 +0200
@@ -15,7 +15,9 @@
 use core::ops::Range;
 use core::ops::RangeBounds;
 use core::ptr;
-use core::str::FromStr;
+use core::str::{self, FromStr};
+use std::ffi::CStr;
+#[cfg(procmacro2_semver_exempt)]
 use std::path::PathBuf;
 
 /// Force use of proc-macro2's fallback implementation of the API for now, even
@@ -297,11 +299,13 @@
     }
 }
 
+#[cfg(procmacro2_semver_exempt)]
 #[derive(Clone, PartialEq, Eq)]
 pub(crate) struct SourceFile {
     path: PathBuf,
 }
 
+#[cfg(procmacro2_semver_exempt)]
 impl SourceFile {
     /// Get the path to this source file as a string.
     pub fn path(&self) -> PathBuf {
@@ -313,6 +317,7 @@
     }
 }
 
+#[cfg(procmacro2_semver_exempt)]
 impl Debug for SourceFile {
     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
         f.debug_struct("SourceFile")
@@ -922,7 +927,7 @@
 
 #[derive(Clone)]
 pub(crate) struct Literal {
-    repr: String,
+    pub(crate) repr: String,
     span: Span,
 }
 
@@ -1003,71 +1008,98 @@
         Literal::_new(s)
     }
 
-    pub fn string(t: &str) -> Literal {
-        let mut repr = String::with_capacity(t.len() + 2);
+    pub fn string(string: &str) -> Literal {
+        let mut repr = String::with_capacity(string.len() + 2);
         repr.push('"');
-        let mut chars = t.chars();
-        while let Some(ch) = chars.next() {
-            if ch == '\0' {
-                repr.push_str(
-                    if chars
-                        .as_str()
-                        .starts_with(|next| '0' <= next && next <= '7')
-                    {
-                        // circumvent clippy::octal_escapes lint
-                        "\\x00"
-                    } else {
-                        "\\0"
-                    },
-                );
-            } else if ch == '\'' {
-                // escape_debug turns this into "\'" which is unnecessary.
-                repr.push(ch);
-            } else {
-                repr.extend(ch.escape_debug());
-            }
-        }
+        escape_utf8(string, &mut repr);
         repr.push('"');
         Literal::_new(repr)
     }
 
-    pub fn character(t: char) -> Literal {
+    pub fn character(ch: char) -> Literal {
         let mut repr = String::new();
         repr.push('\'');
-        if t == '"' {
+        if ch == '"' {
             // escape_debug turns this into '\"' which is unnecessary.
-            repr.push(t);
+            repr.push(ch);
         } else {
-            repr.extend(t.escape_debug());
+            repr.extend(ch.escape_debug());
+        }
+        repr.push('\'');
+        Literal::_new(repr)
+    }
+
+    pub fn byte_character(byte: u8) -> Literal {
+        let mut repr = "b'".to_string();
+        #[allow(clippy::match_overlapping_arm)]
+        match byte {
+            b'\0' => repr.push_str(r"\0"),
+            b'\t' => repr.push_str(r"\t"),
+            b'\n' => repr.push_str(r"\n"),
+            b'\r' => repr.push_str(r"\r"),
+            b'\'' => repr.push_str(r"\'"),
+            b'\\' => repr.push_str(r"\\"),
+            b'\x20'..=b'\x7E' => repr.push(byte as char),
+            _ => {
+                let _ = write!(repr, r"\x{:02X}", byte);
+            }
         }
         repr.push('\'');
         Literal::_new(repr)
     }
 
     pub fn byte_string(bytes: &[u8]) -> Literal {
-        let mut escaped = "b\"".to_string();
+        let mut repr = "b\"".to_string();
         let mut bytes = bytes.iter();
         while let Some(&b) = bytes.next() {
             #[allow(clippy::match_overlapping_arm)]
             match b {
-                b'\0' => escaped.push_str(match bytes.as_slice().first() {
+                b'\0' => repr.push_str(match bytes.as_slice().first() {
                     // circumvent clippy::octal_escapes lint
                     Some(b'0'..=b'7') => r"\x00",
                     _ => r"\0",
                 }),
-                b'\t' => escaped.push_str(r"\t"),
-                b'\n' => escaped.push_str(r"\n"),
-                b'\r' => escaped.push_str(r"\r"),
-                b'"' => escaped.push_str("\\\""),
-                b'\\' => escaped.push_str("\\\\"),
-                b'\x20'..=b'\x7E' => escaped.push(b as char),
+                b'\t' => repr.push_str(r"\t"),
+                b'\n' => repr.push_str(r"\n"),
+                b'\r' => repr.push_str(r"\r"),
+                b'"' => repr.push_str("\\\""),
+                b'\\' => repr.push_str(r"\\"),
+                b'\x20'..=b'\x7E' => repr.push(b as char),
                 _ => {
-                    let _ = write!(escaped, "\\x{:02X}", b);
+                    let _ = write!(repr, r"\x{:02X}", b);
                 }
             }
         }
-        escaped.push('"');
-        Literal::_new(escaped)
+        repr.push('"');
+        Literal::_new(repr)
+    }
+
+    pub fn c_string(string: &CStr) -> Literal {
+        let mut repr = "c\"".to_string();
+        let mut bytes = string.to_bytes();
+        while !bytes.is_empty() {
+            let (valid, invalid) = match str::from_utf8(bytes) {
+                Ok(all_valid) => {
+                    bytes = b"";
+                    (all_valid, bytes)
+                }
+                Err(utf8_error) => {
+                    let (valid, rest) = bytes.split_at(utf8_error.valid_up_to());
+                    let valid = str::from_utf8(valid).unwrap();
+                    let invalid = utf8_error
+                        .error_len()
+                        .map_or(rest, |error_len| &rest[..error_len]);
+                    bytes = &bytes[valid.len() + invalid.len()..];
+                    (valid, invalid)
+                }
+            };
+            escape_utf8(valid, &mut repr);
+            for &byte in invalid {
+                let _ = write!(repr, r"\x{:02X}", byte);
+            }
+        }
+        repr.push('"');
+        Literal::_new(repr)
     }
 
     pub fn span(&self) -> Span {
@@ -1168,3 +1200,27 @@
         debug.finish()
     }
 }
+
+fn escape_utf8(string: &str, repr: &mut String) {
+    let mut chars = string.chars();
+    while let Some(ch) = chars.next() {
+        if ch == '\0' {
+            repr.push_str(
+                if chars
+                    .as_str()
+                    .starts_with(|next| '0' <= next && next <= '7')
+                {
+                    // circumvent clippy::octal_escapes lint
+                    r"\x00"
+                } else {
+                    r"\0"
+                },
+            );
+        } else if ch == '\'' {
+            // escape_debug turns this into "\'" which is unnecessary.
+            repr.push(ch);
+        } else {
+            repr.extend(ch.escape_debug());
+        }
+    }
+}
diff -Nur chromium-123.0.6312.122/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.78/src/lib.rs chromium-125.0.6422.60/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.80/src/lib.rs
--- chromium-123.0.6312.122/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.78/src/lib.rs	2024-04-10 23:25:21.000000000 +0200
+++ chromium-125.0.6422.60/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.80/src/lib.rs	2024-05-15 23:47:24.000000000 +0200
@@ -86,7 +86,7 @@
 //! a different thread.
 
 // Proc-macro2 types in rustdoc of other crates get linked to here.
-#![doc(html_root_url = "https://docs.rs/proc-macro2/1.0.78")]
+#![doc(html_root_url = "https://docs.rs/proc-macro2/1.0.80")]
 #![cfg_attr(any(proc_macro_span, super_unstable), feature(proc_macro_span))]
 #![cfg_attr(super_unstable, feature(proc_macro_def_site))]
 #![cfg_attr(doc_cfg, feature(doc_cfg))]
@@ -96,6 +96,7 @@
     clippy::cast_possible_truncation,
     clippy::checked_conversions,
     clippy::doc_markdown,
+    clippy::incompatible_msrv,
     clippy::items_after_statements,
     clippy::iter_without_into_iter,
     clippy::let_underscore_untyped,
@@ -169,6 +170,7 @@
 use core::ops::RangeBounds;
 use core::str::FromStr;
 use std::error::Error;
+use std::ffi::CStr;
 #[cfg(procmacro2_semver_exempt)]
 use std::path::PathBuf;
 
@@ -1233,9 +1235,19 @@
         Literal::_new(imp::Literal::character(ch))
     }
 
+    /// Byte character literal.
+    pub fn byte_character(byte: u8) -> Literal {
+        Literal::_new(imp::Literal::byte_character(byte))
+    }
+
     /// Byte string literal.
-    pub fn byte_string(s: &[u8]) -> Literal {
-        Literal::_new(imp::Literal::byte_string(s))
+    pub fn byte_string(bytes: &[u8]) -> Literal {
+        Literal::_new(imp::Literal::byte_string(bytes))
+    }
+
+    /// C string literal.
+    pub fn c_string(string: &CStr) -> Literal {
+        Literal::_new(imp::Literal::c_string(string))
     }
 
     /// Returns the span encompassing this literal.
diff -Nur chromium-123.0.6312.122/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.78/src/wrapper.rs chromium-125.0.6422.60/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.80/src/wrapper.rs
--- chromium-123.0.6312.122/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.78/src/wrapper.rs	2024-04-10 23:25:21.000000000 +0200
+++ chromium-125.0.6422.60/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.80/src/wrapper.rs	2024-05-15 23:47:24.000000000 +0200
@@ -7,6 +7,7 @@
 use core::ops::Range;
 use core::ops::RangeBounds;
 use core::str::FromStr;
+use std::ffi::CStr;
 use std::panic;
 #[cfg(super_unstable)]
 use std::path::PathBuf;
@@ -846,19 +847,38 @@
         }
     }
 
-    pub fn string(t: &str) -> Literal {
+    pub fn string(string: &str) -> Literal {
         if inside_proc_macro() {
-            Literal::Compiler(proc_macro::Literal::string(t))
+            Literal::Compiler(proc_macro::Literal::string(string))
         } else {
-            Literal::Fallback(fallback::Literal::string(t))
+            Literal::Fallback(fallback::Literal::string(string))
         }
     }
 
-    pub fn character(t: char) -> Literal {
+    pub fn character(ch: char) -> Literal {
         if inside_proc_macro() {
-            Literal::Compiler(proc_macro::Literal::character(t))
+            Literal::Compiler(proc_macro::Literal::character(ch))
         } else {
-            Literal::Fallback(fallback::Literal::character(t))
+            Literal::Fallback(fallback::Literal::character(ch))
+        }
+    }
+
+    pub fn byte_character(byte: u8) -> Literal {
+        if inside_proc_macro() {
+            Literal::Compiler({
+                #[cfg(not(no_literal_byte_character))]
+                {
+                    proc_macro::Literal::byte_character(byte)
+                }
+
+                #[cfg(no_literal_byte_character)]
+                {
+                    let fallback = fallback::Literal::byte_character(byte);
+                    fallback.repr.parse::<proc_macro::Literal>().unwrap()
+                }
+            })
+        } else {
+            Literal::Fallback(fallback::Literal::byte_character(byte))
         }
     }
 
@@ -870,6 +890,25 @@
         }
     }
 
+    pub fn c_string(string: &CStr) -> Literal {
+        if inside_proc_macro() {
+            Literal::Compiler({
+                #[cfg(not(no_literal_c_string))]
+                {
+                    proc_macro::Literal::c_string(string)
+                }
+
+                #[cfg(no_literal_c_string)]
+                {
+                    let fallback = fallback::Literal::c_string(string);
+                    fallback.repr.parse::<proc_macro::Literal>().unwrap()
+                }
+            })
+        } else {
+            Literal::Fallback(fallback::Literal::c_string(string))
+        }
+    }
+
     pub fn span(&self) -> Span {
         match self {
             Literal::Compiler(lit) => Span::Compiler(lit.span()),
diff -Nur chromium-123.0.6312.122/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.78/tests/marker.rs chromium-125.0.6422.60/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.80/tests/marker.rs
--- chromium-123.0.6312.122/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.78/tests/marker.rs	2024-04-10 23:25:21.000000000 +0200
+++ chromium-125.0.6422.60/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.80/tests/marker.rs	2024-05-15 23:47:24.000000000 +0200
@@ -21,6 +21,7 @@
             $(
                 {
                     // Implemented for types that implement $marker.
+                    #[allow(dead_code)]
                     trait IsNotImplemented {
                         fn assert_not_implemented() {}
                     }
diff -Nur chromium-123.0.6312.122/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.78/tests/test.rs chromium-125.0.6422.60/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.80/tests/test.rs
--- chromium-123.0.6312.122/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.78/tests/test.rs	2024-04-10 23:25:21.000000000 +0200
+++ chromium-125.0.6422.60/third_party/rust/chromium_crates_io/vendor/proc-macro2-1.0.80/tests/test.rs	2024-05-15 23:47:24.000000000 +0200
@@ -1,11 +1,14 @@
 #![allow(
     clippy::assertions_on_result_states,
     clippy::items_after_statements,
+    clippy::needless_pass_by_value,
+    clippy::needless_raw_string_hashes,
     clippy::non_ascii_literal,
     clippy::octal_escapes
 )]
 
 use proc_macro2::{Ident, Literal, Punct, Spacing, Span, TokenStream, TokenTree};
+use std::ffi::CStr;
 use std::iter;
 use std::str::{self, FromStr};
 
@@ -96,12 +99,22 @@
 
 #[test]
 fn literal_string() {
-    assert_eq!(Literal::string("foo").to_string(), "\"foo\"");
-    assert_eq!(Literal::string("\"").to_string(), "\"\\\"\"");
-    assert_eq!(Literal::string("didn't").to_string(), "\"didn't\"");
-    assert_eq!(
-        Literal::string("a\00b\07c\08d\0e\0").to_string(),
-        "\"a\\x000b\\x007c\\08d\\0e\\0\"",
+    #[track_caller]
+    fn assert(literal: Literal, expected: &str) {
+        assert_eq!(literal.to_string(), expected.trim());
+    }
+
+    assert(Literal::string(""), r#"  ""  "#);
+    assert(Literal::string("aA"), r#"  "aA"  "#);
+    assert(Literal::string("\t"), r#"  "\t"  "#);
+    assert(Literal::string("❤"), r#"  "❤"  "#);
+    assert(Literal::string("'"), r#"  "'"  "#);
+    assert(Literal::string("\""), r#"  "\""  "#);
+    assert(Literal::string("\0"), r#"  "\0"  "#);
+    assert(Literal::string("\u{1}"), r#"  "\u{1}"  "#);
+    assert(
+        Literal::string("a\00b\07c\08d\0e\0"),
+        r#"  "a\x000b\x007c\08d\0e\0"  "#,
     );
 
     "\"\\\r\n    x\"".parse::<TokenStream>().unwrap();
@@ -133,15 +146,42 @@
 }
 
 #[test]
+fn literal_byte_character() {
+    #[track_caller]
+    fn assert(literal: Literal, expected: &str) {
+        assert_eq!(literal.to_string(), expected.trim());
+    }
+
+    assert(Literal::byte_character(b'a'), r#"  b'a'  "#);
+    assert(Literal::byte_character(b'\0'), r#"  b'\0'  "#);
+    assert(Literal::byte_character(b'\t'), r#"  b'\t'  "#);
+    assert(Literal::byte_character(b'\n'), r#"  b'\n'  "#);
+    assert(Literal::byte_character(b'\r'), r#"  b'\r'  "#);
+    assert(Literal::byte_character(b'\''), r#"  b'\''  "#);
+    assert(Literal::byte_character(b'\\'), r#"  b'\\'  "#);
+    assert(Literal::byte_character(b'\x1f'), r#"  b'\x1F'  "#);
+    assert(Literal::byte_character(b'"'), r#"  b'"'  "#);
+}
+
+#[test]
 fn literal_byte_string() {
-    assert_eq!(Literal::byte_string(b"").to_string(), "b\"\"");
-    assert_eq!(
-        Literal::byte_string(b"\0\t\n\r\"\\2\x10").to_string(),
-        "b\"\\0\\t\\n\\r\\\"\\\\2\\x10\"",
-    );
-    assert_eq!(
-        Literal::byte_string(b"a\00b\07c\08d\0e\0").to_string(),
-        "b\"a\\x000b\\x007c\\08d\\0e\\0\"",
+    #[track_caller]
+    fn assert(literal: Literal, expected: &str) {
+        assert_eq!(literal.to_string(), expected.trim());
+    }
+
+    assert(Literal::byte_string(b""), r#"  b""  "#);
+    assert(Literal::byte_string(b"\0"), r#"  b"\0"  "#);
+    assert(Literal::byte_string(b"\t"), r#"  b"\t"  "#);
+    assert(Literal::byte_string(b"\n"), r#"  b"\n"  "#);
+    assert(Literal::byte_string(b"\r"), r#"  b"\r"  "#);
+    assert(Literal::byte_string(b"\""), r#"  b"\""  "#);
+    assert(Literal::byte_string(b"\\"), r#"  b"\\"  "#);
+    assert(Literal::byte_string(b"\x1f"), r#"  b"\x1F"  "#);
+    assert(Literal::byte_string(b"'"), r#"  b"'"  "#);
+    assert(
+        Literal::byte_string(b"a\00b\07c\08d\0e\0"),
+        r#"  b"a\x000b\x007c\08d\0e\0"  "#,
     );
 
     "b\"\\\r\n    x\"".parse::<TokenStream>().unwrap();
@@ -152,6 +192,41 @@
 
 #[test]
 fn literal_c_string() {
+    #[track_caller]
+    fn assert(literal: Literal, expected: &str) {
+        assert_eq!(literal.to_string(), expected.trim());
+    }
+
+    assert(Literal::c_string(<&CStr>::default()), r#"  c""  "#);
+    assert(
+        Literal::c_string(CStr::from_bytes_with_nul(b"aA\0").unwrap()),
+        r#"  c"aA"  "#,
+    );
+    assert(
+        Literal::c_string(CStr::from_bytes_with_nul(b"aA\0").unwrap()),
+        r#"  c"aA"  "#,
+    );
+    assert(
+        Literal::c_string(CStr::from_bytes_with_nul(b"\t\0").unwrap()),
+        r#"  c"\t"  "#,
+    );
+    assert(
+        Literal::c_string(CStr::from_bytes_with_nul(b"\xE2\x9D\xA4\0").unwrap()),
+        r#"  c"❤"  "#,
+    );
+    assert(
+        Literal::c_string(CStr::from_bytes_with_nul(b"'\0").unwrap()),
+        r#"  c"'"  "#,
+    );
+    assert(
+        Literal::c_string(CStr::from_bytes_with_nul(b"\"\0").unwrap()),
+        r#"  c"\""  "#,
+    );
+    assert(
+        Literal::c_string(CStr::from_bytes_with_nul(b"\x7F\xFF\xFE\xCC\xB3\0").unwrap()),
+        r#"  c"\u{7f}\xFF\xFE\u{333}"  "#,
+    );
+
     let strings = r###"
         c"hello\x80我叫\u{1F980}"  // from the RFC
         cr"\"
@@ -188,49 +263,80 @@
 
 #[test]
 fn literal_character() {
-    assert_eq!(Literal::character('x').to_string(), "'x'");
-    assert_eq!(Literal::character('\'').to_string(), "'\\''");
-    assert_eq!(Literal::character('"').to_string(), "'\"'");
+    #[track_caller]
+    fn assert(literal: Literal, expected: &str) {
+        assert_eq!(literal.to_string(), expected.trim());
+    }
+
+    assert(Literal::character('a'), r#"  'a'  "#);
+    assert(Literal::character('\t'), r#"  '\t'  "#);
+    assert(Literal::character('❤'), r#"  '❤'  "#);
+    assert(Literal::character('\''), r#"  '\''  "#);
+    assert(Literal::character('"'), r#"  '"'  "#);
+    assert(Literal::character('\0'), r#"  '\0'  "#);
+    assert(Literal::character('\u{1}'), r#"  '\u{1}'  "#);
 }
 
 #[test]
 fn literal_integer() {
-    assert_eq!(Literal::u8_suffixed(10).to_string(), "10u8");
-    assert_eq!(Literal::u16_suffixed(10).to_string(), "10u16");
-    assert_eq!(Literal::u32_suffixed(10).to_string(), "10u32");
-    assert_eq!(Literal::u64_suffixed(10).to_string(), "10u64");
-    assert_eq!(Literal::u128_suffixed(10).to_string(), "10u128");
-    assert_eq!(Literal::usize_suffixed(10).to_string(), "10usize");
-
-    assert_eq!(Literal::i8_suffixed(10).to_string(), "10i8");
-    assert_eq!(Literal::i16_suffixed(10).to_string(), "10i16");
-    assert_eq!(Literal::i32_suffixed(10).to_string(), "10i32");
-    assert_eq!(Literal::i64_suffixed(10).to_string(), "10i64");
-    assert_eq!(Literal::i128_suffixed(10).to_string(), "10i128");
-    assert_eq!(Literal::isize_suffixed(10).to_string(), "10isize");
-
-    assert_eq!(Literal::u8_unsuffixed(10).to_string(), "10");
-    assert_eq!(Literal::u16_unsuffixed(10).to_string(), "10");
-    assert_eq!(Literal::u32_unsuffixed(10).to_string(), "10");
-    assert_eq!(Literal::u64_unsuffixed(10).to_string(), "10");
-    assert_eq!(Literal::u128_unsuffixed(10).to_string(), "10");
-    assert_eq!(Literal::usize_unsuffixed(10).to_string(), "10");
-
-    assert_eq!(Literal::i8_unsuffixed(10).to_string(), "10");
-    assert_eq!(Literal::i16_unsuffixed(10).to_string(), "10");
-    assert_eq!(Literal::i32_unsuffixed(10).to_string(), "10");
-    assert_eq!(Literal::i64_unsuffixed(10).to_string(), "10");
-    assert_eq!(Literal::i128_unsuffixed(10).to_string(), "10");
-    assert_eq!(Literal::isize_unsuffixed(10).to_string(), "10");
+    #[track_caller]
+    fn assert(literal: Literal, expected: &str) {
+        assert_eq!(literal.to_string(), expected);
+    }
+
+    assert(Literal::u8_suffixed(10), "10u8");
+    assert(Literal::u16_suffixed(10), "10u16");
+    assert(Literal::u32_suffixed(10), "10u32");
+    assert(Literal::u64_suffixed(10), "10u64");
+    assert(Literal::u128_suffixed(10), "10u128");
+    assert(Literal::usize_suffixed(10), "10usize");
+
+    assert(Literal::i8_suffixed(10), "10i8");
+    assert(Literal::i16_suffixed(10), "10i16");
+    assert(Literal::i32_suffixed(10), "10i32");
+    assert(Literal::i64_suffixed(10), "10i64");
+    assert(Literal::i128_suffixed(10), "10i128");
+    assert(Literal::isize_suffixed(10), "10isize");
+
+    assert(Literal::u8_unsuffixed(10), "10");
+    assert(Literal::u16_unsuffixed(10), "10");
+    assert(Literal::u32_unsuffixed(10), "10");
+    assert(Literal::u64_unsuffixed(10), "10");
+    assert(Literal::u128_unsuffixed(10), "10");
+    assert(Literal::usize_unsuffixed(10), "10");
+
+    assert(Literal::i8_unsuffixed(10), "10");
+    assert(Literal::i16_unsuffixed(10), "10");
+    assert(Literal::i32_unsuffixed(10), "10");
+    assert(Literal::i64_unsuffixed(10), "10");
+    assert(Literal::i128_unsuffixed(10), "10");
+    assert(Literal::isize_unsuffixed(10), "10");
+
+    assert(Literal::i32_suffixed(-10), "-10i32");
+    assert(Literal::i32_unsuffixed(-10), "-10");
 }
 
 #[test]
 fn literal_float() {
-    assert_eq!(Literal::f32_suffixed(10.0).to_string(), "10f32");
-    assert_eq!(Literal::f64_suffixed(10.0).to_string(), "10f64");
-
-    assert_eq!(Literal::f32_unsuffixed(10.0).to_string(), "10.0");
-    assert_eq!(Literal::f64_unsuffixed(10.0).to_string(), "10.0");
+    #[track_caller]
+    fn assert(literal: Literal, expected: &str) {
+        assert_eq!(literal.to_string(), expected);
+    }
+
+    assert(Literal::f32_suffixed(10.0), "10f32");
+    assert(Literal::f32_suffixed(-10.0), "-10f32");
+    assert(Literal::f64_suffixed(10.0), "10f64");
+    assert(Literal::f64_suffixed(-10.0), "-10f64");
+
+    assert(Literal::f32_unsuffixed(10.0), "10.0");
+    assert(Literal::f32_unsuffixed(-10.0), "-10.0");
+    assert(Literal::f64_unsuffixed(10.0), "10.0");
+    assert(Literal::f64_unsuffixed(-10.0), "-10.0");
+
+    assert(
+        Literal::f64_unsuffixed(1e100),
+        "10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0",
+    );
 }
 
 #[test]
@@ -248,9 +354,13 @@
     assert_eq!(token_count("1._m"), 3);
     assert_eq!(token_count("\"\"s"), 1);
     assert_eq!(token_count("r\"\"r"), 1);
+    assert_eq!(token_count("r#\"\"#r"), 1);
     assert_eq!(token_count("b\"\"b"), 1);
     assert_eq!(token_count("br\"\"br"), 1);
-    assert_eq!(token_count("r#\"\"#r"), 1);
+    assert_eq!(token_count("br#\"\"#br"), 1);
+    assert_eq!(token_count("c\"\"c"), 1);
+    assert_eq!(token_count("cr\"\"cr"), 1);
+    assert_eq!(token_count("cr#\"\"#cr"), 1);
     assert_eq!(token_count("'c'c"), 1);
     assert_eq!(token_count("b'b'b"), 1);
     assert_eq!(token_count("0E"), 1);
@@ -378,7 +488,7 @@
     roundtrip("'a");
     roundtrip("'_");
     roundtrip("'static");
-    roundtrip("'\\u{10__FFFF}'");
+    roundtrip(r"'\u{10__FFFF}'");
     roundtrip("\"\\u{10_F0FF__}foo\\u{1_0_0_0__}\"");
 }
 
@@ -401,6 +511,7 @@
     fail("\"\\\r  \""); // backslash carriage return
     fail("'aa'aa");
     fail("br##\"\"#");
+    fail("cr##\"\"#");
     fail("\"\\\n\u{85}\r\"");
 }
 
