diff -up chromium-125.0.6422.60/base/allocator/partition_allocator/src/partition_alloc/internal_allocator.h.typename chromium-125.0.6422.60/base/allocator/partition_allocator/src/partition_alloc/internal_allocator.h
--- chromium-125.0.6422.60/base/allocator/partition_allocator/src/partition_alloc/internal_allocator.h.typename	2024-05-15 23:45:49.000000000 +0200
+++ chromium-125.0.6422.60/base/allocator/partition_allocator/src/partition_alloc/internal_allocator.h	2024-05-17 12:33:58.735650966 +0200
@@ -26,7 +26,7 @@ PartitionRoot& InternalAllocatorRoot();
 
 // A class that meets C++ named requirements, Allocator.
 template <typename T>
-InternalAllocator<T>::value_type* InternalAllocator<T>::allocate(
+typename InternalAllocator<T>::value_type* InternalAllocator<T>::allocate(
     std::size_t count) {
   PA_CHECK(count <=
            std::numeric_limits<std::size_t>::max() / sizeof(value_type));
diff -up chromium-125.0.6422.60/base/containers/heap_array.h.typename chromium-125.0.6422.60/base/containers/heap_array.h
--- chromium-125.0.6422.60/base/containers/heap_array.h.typename	2024-05-17 13:51:39.923426461 +0200
+++ chromium-125.0.6422.60/base/containers/heap_array.h	2024-05-17 13:54:01.866085730 +0200
@@ -32,8 +32,8 @@ class TRIVIAL_ABI GSL_OWNER HeapArray {
   static_assert(!std::is_reference_v<T>,
                 "HeapArray cannot hold reference types");
 
-  using iterator = base::span<T>::iterator;
-  using const_iterator = base::span<const T>::iterator;
+  using iterator = typename base::span<T>::iterator;
+  using const_iterator = typename base::span<const T>::iterator;
   // We don't put this default value in the template parameter list to allow the
   // static_assert on is_reference_v to give a nicer error message.
   using deleter_type = std::
diff -up chromium-125.0.6422.60/base/containers/map_util.h.typename chromium-125.0.6422.60/base/containers/map_util.h
--- chromium-125.0.6422.60/base/containers/map_util.h.typename	2024-05-15 23:45:49.000000000 +0200
+++ chromium-125.0.6422.60/base/containers/map_util.h	2024-05-17 12:33:58.735650966 +0200
@@ -44,7 +44,7 @@ constexpr internal::MappedType<Map>* Fin
 template <typename Map,
           typename Key,
           typename MappedElementType =
-              std::pointer_traits<internal::MappedType<Map>>::element_type>
+              typename std::pointer_traits<internal::MappedType<Map>>::element_type>
 constexpr const MappedElementType* FindPtrOrNull(const Map& map,
                                                  const Key& key) {
   auto it = map.find(key);
@@ -60,7 +60,7 @@ constexpr const MappedElementType* FindP
 template <typename Map,
           typename Key,
           typename MappedElementType =
-              std::pointer_traits<internal::MappedType<Map>>::element_type>
+              typename std::pointer_traits<internal::MappedType<Map>>::element_type>
 constexpr MappedElementType* FindPtrOrNull(Map& map, const Key& key) {
   auto it = map.find(key);
   return it != map.end() ? base::to_address(it->second) : nullptr;
diff -up chromium-125.0.6422.60/base/containers/to_vector.h.typename chromium-125.0.6422.60/base/containers/to_vector.h
--- chromium-125.0.6422.60/base/containers/to_vector.h.typename	2024-05-15 23:45:49.000000000 +0200
+++ chromium-125.0.6422.60/base/containers/to_vector.h	2024-05-17 12:33:58.736650987 +0200
@@ -30,7 +30,7 @@ template <typename Range, typename Proj
            std::indirectly_unary_invocable<Proj, ranges::iterator_t<Range>>
 auto ToVector(Range&& range, Proj proj = {}) {
   using ProjectedType =
-      std::projected<ranges::iterator_t<Range>, Proj>::value_type;
+      typename std::projected<ranges::iterator_t<Range>, Proj>::value_type;
   std::vector<ProjectedType> container;
   container.reserve(std::size(range));
   ranges::transform(std::forward<Range>(range), std::back_inserter(container),
diff -up chromium-125.0.6422.60/base/functional/bind_internal.h.typename chromium-125.0.6422.60/base/functional/bind_internal.h
--- chromium-125.0.6422.60/base/functional/bind_internal.h.typename	2024-05-15 23:45:49.000000000 +0200
+++ chromium-125.0.6422.60/base/functional/bind_internal.h	2024-05-17 12:33:58.736650987 +0200
@@ -1505,11 +1505,11 @@ template <int i,
           typename Param>
 struct ParamCanBeBound {
  private:
-  using UnwrappedParam = BindArgument<i>::template ForwardedAs<
+  using UnwrappedParam = typename BindArgument<i>::template ForwardedAs<
       Unwrapped>::template ToParamWithType<Param>;
-  using ParamStorage = BindArgument<i>::template ToParamWithType<
+  using ParamStorage = typename BindArgument<i>::template ToParamWithType<
       Param>::template StoredAs<Storage>;
-  using BoundStorage =
+  using BoundStorage = typename
       BindArgument<i>::template BoundAs<Arg>::template StoredAs<Storage>;
 
   template <bool v = !UnwrappedParam::kRawPtr ||
diff -up chromium-125.0.6422.60/base/functional/function_ref.h.typename chromium-125.0.6422.60/base/functional/function_ref.h
--- chromium-125.0.6422.60/base/functional/function_ref.h.typename	2024-05-15 23:45:49.000000000 +0200
+++ chromium-125.0.6422.60/base/functional/function_ref.h	2024-05-17 12:33:58.736650987 +0200
@@ -64,7 +64,7 @@ class FunctionRef;
 template <typename R, typename... Args>
 class FunctionRef<R(Args...)> {
   template <typename Functor,
-            typename RunType = internal::FunctorTraits<Functor>::RunType>
+            typename RunType = typename internal::FunctorTraits<Functor>::RunType>
   static constexpr bool kCompatibleFunctor =
       std::convertible_to<internal::ExtractReturnType<RunType>, R> &&
       std::same_as<internal::ExtractArgs<RunType>, internal::TypeList<Args...>>;
diff -up chromium-125.0.6422.60/base/types/fixed_array.h.typename chromium-125.0.6422.60/base/types/fixed_array.h
--- chromium-125.0.6422.60/base/types/fixed_array.h.typename	2024-05-15 23:45:50.000000000 +0200
+++ chromium-125.0.6422.60/base/types/fixed_array.h	2024-05-17 12:33:58.737651008 +0200
@@ -27,8 +27,8 @@ template <typename T,
 class FixedArray : public absl::FixedArray<T, N, A> {
  public:
   using absl::FixedArray<T, N, A>::FixedArray;
-  explicit FixedArray(absl::FixedArray<T, N, A>::size_type n,
-                      const absl::FixedArray<T, N, A>::allocator_type& a =
+  explicit FixedArray(typename absl::FixedArray<T, N, A>::size_type n,
+                      const typename absl::FixedArray<T, N, A>::allocator_type& a =
                           typename absl::FixedArray<T, N, A>::allocator_type())
       : FixedArray(n, T(), a) {}
 };
diff -up chromium-125.0.6422.60/chrome/browser/download/bubble/download_bubble_update_service.cc.typename chromium-125.0.6422.60/chrome/browser/download/bubble/download_bubble_update_service.cc
--- chromium-125.0.6422.60/chrome/browser/download/bubble/download_bubble_update_service.cc.typename	2024-05-15 23:46:00.000000000 +0200
+++ chromium-125.0.6422.60/chrome/browser/download/bubble/download_bubble_update_service.cc	2024-05-17 12:33:58.737651008 +0200
@@ -94,7 +94,7 @@ ItemSortKey GetSortKey(const Item& item)
 // Helper to get an iterator to the last element in the cache. The cache
 // must not be empty.
 template <typename Item>
-SortedItems<Item>::const_iterator GetLastIter(const SortedItems<Item>& cache) {
+typename SortedItems<Item>::const_iterator GetLastIter(const SortedItems<Item>& cache) {
   CHECK(!cache.empty());
   auto it = cache.end();
   return std::prev(it);
@@ -1173,9 +1173,9 @@ bool DownloadBubbleUpdateService::CacheM
 }
 
 template <typename Id, typename Item>
-SortedItems<Item>::iterator
+typename SortedItems<Item>::iterator
 DownloadBubbleUpdateService::CacheManager::RemoveItemFromCacheByIter(
-    SortedItems<Item>::iterator iter,
+    typename SortedItems<Item>::iterator iter,
     SortedItems<Item>& cache,
     IterMap<Id, Item>& iter_map) {
   CHECK(iter != cache.end());
diff -up chromium-125.0.6422.60/chrome/browser/web_applications/commands/internal/command_internal.h.typename chromium-125.0.6422.60/chrome/browser/web_applications/commands/internal/command_internal.h
--- chromium-125.0.6422.60/chrome/browser/web_applications/commands/internal/command_internal.h.typename	2024-05-15 23:46:06.000000000 +0200
+++ chromium-125.0.6422.60/chrome/browser/web_applications/commands/internal/command_internal.h	2024-05-17 12:33:58.737651008 +0200
@@ -121,7 +121,7 @@ class CommandBase {
 template <typename LockType>
 class CommandWithLock : public CommandBase {
  public:
-  using LockDescription = LockType::LockDescription;
+  using LockDescription = typename LockType::LockDescription;
   explicit CommandWithLock(const std::string& name,
                            LockDescription initial_lock_request);
 
diff -up chromium-125.0.6422.60/chrome/browser/web_applications/commands/web_app_command.h.typename chromium-125.0.6422.60/chrome/browser/web_applications/commands/web_app_command.h
--- chromium-125.0.6422.60/chrome/browser/web_applications/commands/web_app_command.h.typename	2024-05-15 23:46:06.000000000 +0200
+++ chromium-125.0.6422.60/chrome/browser/web_applications/commands/web_app_command.h	2024-05-17 12:33:58.738651028 +0200
@@ -106,7 +106,7 @@ class WebAppLockManager;
 template <typename LockType, typename... CallbackArgs>
 class WebAppCommand : public internal::CommandWithLock<LockType> {
  public:
-  using LockDescription = LockType::LockDescription;
+  using LockDescription = typename LockType::LockDescription;
   using CallbackType = base::OnceCallback<void(CallbackArgs...)>;
   using ShutdownArgumentsTuple = std::tuple<std::decay_t<CallbackArgs>...>;
 
diff -up chromium-125.0.6422.60/chrome/browser/web_applications/web_app_command_scheduler.h.typename chromium-125.0.6422.60/chrome/browser/web_applications/web_app_command_scheduler.h
--- chromium-125.0.6422.60/chrome/browser/web_applications/web_app_command_scheduler.h.typename	2024-05-15 23:46:06.000000000 +0200
+++ chromium-125.0.6422.60/chrome/browser/web_applications/web_app_command_scheduler.h	2024-05-17 12:33:58.738651028 +0200
@@ -373,7 +373,7 @@ class WebAppCommandScheduler {
   // command system.
   template <typename LockType>
   void ScheduleCallback(const std::string& operation_name,
-                        LockType::LockDescription lock_description,
+                        typename LockType::LockDescription lock_description,
                         CallbackCommand<LockType, void> callback,
                         base::OnceClosure on_complete,
                         const base::Location& location = FROM_HERE) {
@@ -391,7 +391,7 @@ class WebAppCommandScheduler {
             typename CallbackReturnValue = std::decay_t<CompletionCallbackArg>>
   void ScheduleCallbackWithResult(
       const std::string& operation_name,
-      LockType::LockDescription lock_description,
+      typename LockType::LockDescription lock_description,
       CallbackCommand<LockType, CallbackReturnValue> callback,
       base::OnceCallback<void(CompletionCallbackArg)> on_complete,
       CallbackReturnValue arg_for_shutdown,
diff -up chromium-125.0.6422.60/components/optimization_guide/core/model_execution/model_execution_util.h.typename chromium-125.0.6422.60/components/optimization_guide/core/model_execution/model_execution_util.h
--- chromium-125.0.6422.60/components/optimization_guide/core/model_execution/model_execution_util.h.typename	2024-05-15 23:46:13.000000000 +0200
+++ chromium-125.0.6422.60/components/optimization_guide/core/model_execution/model_execution_util.h	2024-05-17 12:33:58.738651028 +0200
@@ -26,7 +26,7 @@ void SetExecutionRequestTemplate(
 
   // Request is set by the feature and should always be typed.
   auto typed_request =
-      static_cast<const FeatureType::Request&>(request_metadata);
+      static_cast<const typename FeatureType::Request&>(request_metadata);
   *(logging_data->mutable_request_data()) = typed_request;
 }
 
diff -up chromium-125.0.6422.60/components/optimization_guide/core/model_quality/model_quality_log_entry.h.typename chromium-125.0.6422.60/components/optimization_guide/core/model_quality/model_quality_log_entry.h
--- chromium-125.0.6422.60/components/optimization_guide/core/model_quality/model_quality_log_entry.h.typename	2024-05-15 23:46:13.000000000 +0200
+++ chromium-125.0.6422.60/components/optimization_guide/core/model_quality/model_quality_log_entry.h	2024-05-17 12:33:58.738651028 +0200
@@ -33,7 +33,7 @@ class ModelQualityLogEntry {
   }
 
   template <typename FeatureType>
-  FeatureType::Quality* quality_data() {
+  typename FeatureType::Quality* quality_data() {
     return FeatureType::GetLoggingData(*log_ai_data_request_)
         ->mutable_quality_data();
   }
diff -up chromium-125.0.6422.60/components/optimization_guide/core/model_quality/model_quality_util.h.typename chromium-125.0.6422.60/components/optimization_guide/core/model_quality/model_quality_util.h
--- chromium-125.0.6422.60/components/optimization_guide/core/model_quality/model_quality_util.h.typename	2024-05-15 23:46:13.000000000 +0200
+++ chromium-125.0.6422.60/components/optimization_guide/core/model_quality/model_quality_util.h	2024-05-17 12:33:58.739651049 +0200
@@ -20,7 +20,7 @@ std::optional<UserVisibleFeatureKey> Get
 // Helper method to get the quality_data from `log_ai_data_request` for
 // different features.
 template <typename FeatureType>
-FeatureType::Quality* GetModelQualityData(
+typename FeatureType::Quality* GetModelQualityData(
     proto::LogAiDataRequest* log_ai_data_request) {
   return FeatureType::GetLoggingData(*log_ai_data_request)
       ->mutable_quality_data();
diff -up chromium-125.0.6422.60/components/optimization_guide/core/tflite_model_executor.h.typename chromium-125.0.6422.60/components/optimization_guide/core/tflite_model_executor.h
--- chromium-125.0.6422.60/components/optimization_guide/core/tflite_model_executor.h.typename	2024-05-15 23:46:13.000000000 +0200
+++ chromium-125.0.6422.60/components/optimization_guide/core/tflite_model_executor.h	2024-05-17 12:33:58.739651049 +0200
@@ -242,7 +242,7 @@ class TFLiteModelExecutor : public Model
   void SendForBatchExecution(
       BatchExecutionCallback callback_on_complete,
       base::TimeTicks start_time,
-      ModelExecutor<OutputType, InputType>::ConstRefInputVector inputs)
+      typename ModelExecutor<OutputType, InputType>::ConstRefInputVector inputs)
       override {
     DCHECK(execution_task_runner_->RunsTasksInCurrentSequence());
     DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
@@ -264,7 +264,7 @@ class TFLiteModelExecutor : public Model
   // Starts the synchronous execution of the model. Returns model outputs.
   // Model needs to be loaded. Synchronous calls do not load or unload model.
   std::vector<std::optional<OutputType>> SendForBatchExecutionSync(
-      ModelExecutor<OutputType, InputType>::ConstRefInputVector inputs)
+      typename ModelExecutor<OutputType, InputType>::ConstRefInputVector inputs)
       override {
     DCHECK(execution_task_runner_->RunsTasksInCurrentSequence());
     DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
@@ -422,7 +422,7 @@ class TFLiteModelExecutor : public Model
   // executes it on the model execution thread.
   void LoadModelFileAndBatchExecute(
       BatchExecutionCallback callback_on_complete,
-      ModelExecutor<OutputType, InputType>::ConstRefInputVector inputs) {
+      typename ModelExecutor<OutputType, InputType>::ConstRefInputVector inputs) {
     DCHECK(execution_task_runner_->RunsTasksInCurrentSequence());
     DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
 
@@ -439,7 +439,7 @@ class TFLiteModelExecutor : public Model
 
   // Batch executes the loaded model for inputs.
   void BatchExecuteLoadedModel(
-      ModelExecutor<OutputType, InputType>::ConstRefInputVector inputs,
+      typename ModelExecutor<OutputType, InputType>::ConstRefInputVector inputs,
       std::vector<std::optional<OutputType>>* outputs) {
     DCHECK(execution_task_runner_->RunsTasksInCurrentSequence());
     DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
@@ -499,7 +499,7 @@ class TFLiteModelExecutor : public Model
   // Unloads the model if needed.
   void BatchExecuteLoadedModelAndRunCallback(
       BatchExecutionCallback callback_on_complete,
-      ModelExecutor<OutputType, InputType>::ConstRefInputVector inputs,
+      typename ModelExecutor<OutputType, InputType>::ConstRefInputVector inputs,
       ExecutionStatus execution_status) {
     DCHECK(execution_task_runner_->RunsTasksInCurrentSequence());
     DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
diff -up chromium-125.0.6422.60/components/supervised_user/core/browser/proto_fetcher.h.typename chromium-125.0.6422.60/components/supervised_user/core/browser/proto_fetcher.h
--- chromium-125.0.6422.60/components/supervised_user/core/browser/proto_fetcher.h.typename	2024-05-15 23:46:15.000000000 +0200
+++ chromium-125.0.6422.60/components/supervised_user/core/browser/proto_fetcher.h	2024-05-17 12:33:58.739651049 +0200
@@ -458,7 +458,7 @@ class RetryingFetcherImpl final : public
   RetryingFetcherImpl(const RetryingFetcherImpl&) = delete;
   RetryingFetcherImpl& operator=(const RetryingFetcherImpl&) = delete;
 
-  void Start(ProtoFetcher<Response>::Callback callback) override {
+  void Start(typename ProtoFetcher<Response>::Callback callback) override {
     callback_ = std::move(callback);
     Retry();
   }
@@ -504,7 +504,7 @@ class RetryingFetcherImpl final : public
   }
 
   // Client callback.
-  TypedProtoFetcher<Response>::Callback callback_;
+  typename TypedProtoFetcher<Response>::Callback callback_;
 
   // Retry controls.
   base::OneShotTimer timer_;
@@ -525,7 +525,7 @@ class ParallelFetchManager {
   // Deferred fetcher is required because it should be started after it is
   // stored internally.
   using Fetcher = ProtoFetcher<Response>;
-  using KeyType = base::IDMap<std::unique_ptr<Fetcher>>::KeyType;
+  using KeyType = typename base::IDMap<std::unique_ptr<Fetcher>>::KeyType;
 
  public:
   // Provides fresh instances of a deferred fetcher for each fetch.
@@ -541,7 +541,7 @@ class ParallelFetchManager {
 
   // Starts the fetch. Underlying fetcher is stored internally, and will be
   // cleaned up after finish or when this manager is destroyed.
-  void Fetch(const Request& request, Fetcher::Callback callback) {
+  void Fetch(const Request& request, typename Fetcher::Callback callback) {
     CHECK(callback) << "Use base::DoNothing() instead of empty callback.";
     KeyType key = requests_in_flight_.Add(MakeFetcher(request));
     requests_in_flight_.Lookup(key)->Start(
diff -up chromium-125.0.6422.60/mojo/public/cpp/bindings/array_traits.h.typename chromium-125.0.6422.60/mojo/public/cpp/bindings/array_traits.h
--- chromium-125.0.6422.60/mojo/public/cpp/bindings/array_traits.h.typename	2024-05-15 23:46:29.000000000 +0200
+++ chromium-125.0.6422.60/mojo/public/cpp/bindings/array_traits.h	2024-05-17 12:33:58.739651049 +0200
@@ -90,7 +90,7 @@ template <typename Container>
     { c[i] } -> std::same_as<typename Container::reference>;
   }
 struct ArrayTraits<Container> {
-  using Element = Container::value_type;
+  using Element = typename Container::value_type;
 
   // vector-like containers have no built-in null.
   static bool IsNull(const Container& c) { return false; }
diff -up chromium-125.0.6422.60/mojo/public/cpp/bindings/type_converter.h.typename chromium-125.0.6422.60/mojo/public/cpp/bindings/type_converter.h
--- chromium-125.0.6422.60/mojo/public/cpp/bindings/type_converter.h.typename	2024-05-15 23:46:30.000000000 +0200
+++ chromium-125.0.6422.60/mojo/public/cpp/bindings/type_converter.h	2024-05-17 12:33:58.740651070 +0200
@@ -127,7 +127,7 @@ using VecValueType = typename Vec::value
 
 template <typename Vec>
 using VecPtrLikeUnderlyingValueType =
-    std::pointer_traits<VecValueType<Vec>>::element_type;
+    typename std::pointer_traits<VecValueType<Vec>>::element_type;
 
 }  // namespace internal
 
diff -up chromium-125.0.6422.60/third_party/blink/renderer/bindings/core/v8/async_iterable.h.typename chromium-125.0.6422.60/third_party/blink/renderer/bindings/core/v8/async_iterable.h
--- chromium-125.0.6422.60/third_party/blink/renderer/bindings/core/v8/async_iterable.h.typename	2024-05-15 23:46:40.000000000 +0200
+++ chromium-125.0.6422.60/third_party/blink/renderer/bindings/core/v8/async_iterable.h	2024-05-17 12:33:58.740651070 +0200
@@ -245,7 +245,7 @@ class PairAsyncIterable {
  private:
   virtual IterationSource* CreateIterationSource(
       ScriptState* script_state,
-      IterationSource::Kind kind,
+      typename IterationSource::Kind kind,
       InitArgs... args,
       ExceptionState& exception_state) = 0;
 };
@@ -291,7 +291,7 @@ class ValueAsyncIterable {
  private:
   virtual IterationSource* CreateIterationSource(
       ScriptState* script_state,
-      IterationSource::Kind kind,
+      typename IterationSource::Kind kind,
       InitArgs... args,
       ExceptionState& exception_state) = 0;
 };
diff -up chromium-125.0.6422.60/third_party/blink/renderer/bindings/core/v8/script_promise_property.h.typename chromium-125.0.6422.60/third_party/blink/renderer/bindings/core/v8/script_promise_property.h
--- chromium-125.0.6422.60/third_party/blink/renderer/bindings/core/v8/script_promise_property.h.typename	2024-05-15 23:46:40.000000000 +0200
+++ chromium-125.0.6422.60/third_party/blink/renderer/bindings/core/v8/script_promise_property.h	2024-05-17 12:33:58.740651070 +0200
@@ -171,7 +171,7 @@ class ScriptPromiseProperty final
   template <typename T>
     requires std::derived_from<T, bindings::EnumerationBase>
   static T DefaultPromiseResultValue() {
-    return T(static_cast<T::Enum>(0));
+    return T(static_cast<typename T::Enum>(0));
   }
 
   State state_ = kPending;
diff -up chromium-125.0.6422.60/third_party/blink/renderer/core/html/parser/html_document_parser_fastpath.cc.typename chromium-125.0.6422.60/third_party/blink/renderer/core/html/parser/html_document_parser_fastpath.cc
--- chromium-125.0.6422.60/third_party/blink/renderer/core/html/parser/html_document_parser_fastpath.cc.typename	2024-05-15 23:46:41.000000000 +0200
+++ chromium-125.0.6422.60/third_party/blink/renderer/core/html/parser/html_document_parser_fastpath.cc	2024-05-17 12:33:58.741651090 +0200
@@ -210,7 +210,7 @@ class HTMLFastPathParser {
   using Span = base::span<const Char>;
   using USpan = base::span<const UChar>;
   // 32 matches that used by HTMLToken::Attribute.
-  typedef std::conditional<std::is_same_v<Char, UChar>,
+  typedef typename std::conditional<std::is_same_v<Char, UChar>,
                            UCharLiteralBuffer<32>,
                            LCharLiteralBuffer<32>>::type LiteralBufferType;
   static_assert(std::is_same_v<Char, UChar> || std::is_same_v<Char, LChar>);
diff -up chromium-125.0.6422.60/third_party/blink/renderer/core/paint/object_paint_properties.h.typename chromium-125.0.6422.60/third_party/blink/renderer/core/paint/object_paint_properties.h
--- chromium-125.0.6422.60/third_party/blink/renderer/core/paint/object_paint_properties.h.typename	2024-05-15 23:46:41.000000000 +0200
+++ chromium-125.0.6422.60/third_party/blink/renderer/core/paint/object_paint_properties.h	2024-05-17 12:33:58.741651090 +0200
@@ -445,8 +445,8 @@ class CORE_EXPORT ObjectPaintProperties
   PaintPropertyChangeType Update(
       NodeId node_id,
       const ParentType& parent,
-      NodeType::State&& state,
-      const NodeType::AnimationState& animation_state =
+      typename NodeType::State&& state,
+      const typename NodeType::AnimationState& animation_state =
           NodeType::AnimationState()) {
     // First, check if we need to add a new node.
     if (!nodes_.HasField(node_id)) {
diff -up chromium-125.0.6422.60/third_party/blink/renderer/platform/wtf/hash_table.h.typename chromium-125.0.6422.60/third_party/blink/renderer/platform/wtf/hash_table.h
--- chromium-125.0.6422.60/third_party/blink/renderer/platform/wtf/hash_table.h.typename	2024-05-15 23:46:43.000000000 +0200
+++ chromium-125.0.6422.60/third_party/blink/renderer/platform/wtf/hash_table.h	2024-05-17 12:33:58.742651111 +0200
@@ -2013,7 +2013,7 @@ struct HashTableConstIteratorAdapter {
   static_assert(!IsTraceable<typename Traits::TraitType>::value);
 
   using iterator_category = std::bidirectional_iterator_tag;
-  using value_type = HashTableType::ValueType;
+  using value_type = typename HashTableType::ValueType;
   using difference_type = ptrdiff_t;
   using pointer = value_type*;
   using reference = value_type&;
@@ -2065,7 +2065,7 @@ struct HashTableConstIteratorAdapter<
 
  public:
   using iterator_category = std::bidirectional_iterator_tag;
-  using value_type = HashTableType::ValueType;
+  using value_type = typename HashTableType::ValueType;
   using difference_type = ptrdiff_t;
   using pointer = value_type*;
   using reference = value_type&;
@@ -2119,7 +2119,7 @@ struct HashTableIteratorAdapter {
   static_assert(!IsTraceable<typename Traits::TraitType>::value);
 
   using iterator_category = std::bidirectional_iterator_tag;
-  using value_type = HashTableType::ValueType;
+  using value_type = typename HashTableType::ValueType;
   using difference_type = ptrdiff_t;
   using pointer = value_type*;
   using reference = value_type&;
@@ -2167,7 +2167,7 @@ struct HashTableIteratorAdapter<
 
  public:
   using iterator_category = std::bidirectional_iterator_tag;
-  using value_type = HashTableType::ValueType;
+  using value_type = typename HashTableType::ValueType;
   using difference_type = ptrdiff_t;
   using pointer = value_type*;
   using reference = value_type&;
